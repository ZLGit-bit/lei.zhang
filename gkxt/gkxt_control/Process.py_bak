# -*- coding:utf-8 -*-
import json
import datetime
import time
import pandas as pd
from sqlalchemy import create_engine
import sys
import os
import MysqlUtils
import redisUtils
reload(sys)
sys.setdefaultencoding('utf-8')

class ControlProcess:
	def __init__(self,conf,sql_context):
		self.sql_context = sql_context
		self.conf = conf

	#判断方法是否执行,如果继续执行返回数据时间和规则时间,不执行返回0
	def judgeExe(self,data,rule):
                prog_rule = rule['prog_rule']
                start_time = str(rule['start_time'])
                end_time = str(rule['end_time'])
                col_time = str(data['col_time'])
		#数据时间如果不在布控范围内，则跳过
                if (col_time>=start_time and col_time<=end_time) or start_time == 'None':
                    col_h = datetime.datetime.strftime(datetime.datetime.strptime(col_time,'%Y-%m-%d %H:%M:%S'),'%H:%M')
                    prog_rule_json = json.loads(str(prog_rule))
                    control_times = prog_rule_json['date_time']
		    return control_times,col_h
		else:
		    return 0
	
	def listappend(self,data_l,rule_l,lr):
		if lr!=0 and len(lr)>0:
		    for data in lr:
		        data_l.append(data[1])
                        rule_l.append(data[0])
		return data_l,rule_l

	#遍历每条数据和每个规则
	def executeFunc(self,data,rule,func_type):
		print 'start->execute'
		data_columns = []
		rule_columns = []
		print data.columns
		print rule.columns
		gather_r_df = rule[rule['control_prog_id'].isin(['5'])]
		pos_r_df = rule[rule['control_prog_id'].isin(['10','11'])]
		per_r_df = rule[rule['control_prog_id'].isin(['1','2','3','4','5','6','7','8','9'])]
		noTrack_r = rule[rule['control_prog_id'].isin(['9'])]
		per_df = data.merge(per_r_df,on=['idcard'],how='inner',suffixs=['','_r'])

		#print rule
		for index,i_data in data.iterrows():
		    for index,row in per_r_df.iterrows():
			func_type = str(row['control_prog_id'])
			r_idcard = row['idcard']
			#1:离开区域,2:票务预警,3:住宿预警,4:上网预警,5:人员聚集,6:进入区域,7:进入区县,8:随动随报,9:轨迹消失,10:离开阵地,11:进入阵地
		        if func_type in ['1']:
			    lr = self.leaveArea(i_data,row)
			    data_l,rule_l = self.listappend(data_l,rule_l,lr)
			if func_type in ['6','7']:
			    ir = self.intoArea(i_data,row)
			    data_l,rule_l = self.listappend(data_l,rule_l,ir)
			if func_type in ['8']:
			    ar = self.appearAlarm(i_data,row)
			    data_l,rule_l = self.listappend(data_l,rule_l,ar)
			if func_type in ['2','3','4']:
			    br = self.behaviorAlarm(i_data,row)
			    data_l,rule_l = self.listappend(data_l,rule_l,br)
	   	    for p_i,p_row in pos_r_df.iterrows():
                            pr = self.positionAlarm(i_data,p_row)
                            data_l,rule_l = self.listappend(data_l,rule_l,pr) 
            	
		for index,data in data.iterrows():
		    for r_i,r_d in noTrack_df.iterrows():
                        pr = self.noTrackAlarm(i_data,row)
                        data_l,rule_l = self.listappend(data_l,rule_l,pr)
                    for g_i,g_d in gather_r_df.iterrows():
                            gr = self.gatherAlarm(i_data,row)
			    if len(gr)>0:
			        for g_data in gr:
			            gather_l.append(g_data[1])
				    gather_r.append(g_data[0])


		rule_df = pd.DataFrame(rule_l)	
		data_df = pd.DataFrame(data_l)
		#return rule_df,data_df
		#print data_df.head(10)
		#更新触境频次表	
		if data_df.shape[0]>0:	
		    self.updateFreq(rule_df,data_df)

		if  len(gather_l)>0:
		    gather_data_df = pd.DataFrame()
		    gather_rule_df = pd.DataFrame()
		    for ind,r_per in rule.iterrows():
			target_id = r_per['target_id']
			redis_id = 'target_id_%s' % target_id
			redis_idcard = r_per['idcard']
			prog_rule_json = json.loads(str(r_per['prog_rule']))
                        people_number = prog_rule_json['people_number']
		        r_data = redisUtils.getGatherInfo(redis_id) 
		        if redisUtils.existsKey(redis_id,redis_idcard):
			    if len(r_data)>=int(people_number):
			        gather_data = pd.DataFrame(gather_l)
				gather_rule = pd.DataFrame(gather_r)
				gather_data_df = gather_data_df.append(gather_data[gather_data[gather_data['idcard'].isin([redis_idcard])]['target_id'].isin([target_id])])
				gather_rule_df = gather_rule_df.append(gather_rule[gather_rule[gather_rule['idcard'].isin([redis_idcard])]['target_id'].isin([target_id])])
                        gr = self.gatherAlarm(i_data,g_row)
                        data_l,rule_l = self.listappend(data_l,rule_l,gr)
		#更新最后一次位置
		self.setLastPlace(data)
		rule_df = pd.DataFrame(rule_l)
		data_df = pd.DataFrame(data_l)
		#更新触境频次表	
		if data_df.shape[0]>0:
		    self.updateFreq(rule_df,data_df)
		if data.shape[0]>0:
		    self.judgeAlarmInfo(gather_r_df)

	#根据redis存储的结果，判断是否触发聚集
	def judgeAlarmInfo(self,rule):
		print 'gather_start'
		print rule.shape[0]
		r_l = []
                if rule.shape[0]>0:
                    gather_data_df = pd.DataFrame()
                    gather_rule_df = pd.DataFrame()
                    for ind,r_per in rule.iterrows():
                        target_id = r_per['target_id']
                        redis_id = 'target_id_%s' % target_id
                        redis_idcard = r_per['idcard']
                        prog_rule_json = json.loads(str(r_per['prog_rule']))
                        people_number = prog_rule_json['people_number']
                        stay_time = prog_rule_json['stay_time']
			if stay_time == 'None' or stay_time == None:
			    stay_time = 5
			r_l.append(self.ruleRes(r_per))
                        #从redis中获取在区域内停留的所有人的数据
                        r_data = self.redisUtil.getGatherInfo(redis_id,stay_time)
			#print redis_id
                        if self.redisUtil.existsKey(redis_id,redis_idcard):
			    print target_id
			    print len(r_data)
			    print r_data
                            if len(r_data)>=int(people_number):
                                gather_data = pd.DataFrame(r_data)
				print gather_data
                                #print gather_data
                                gather_rule = pd.DataFrame(r_l)
				#print gather_rule.head(10)
                                #判断布控人和方案目标是否在停留区域名单中，如果存在更新预警频次
                                #print target_id
                                gather_data_df = gather_data[gather_data['idcard'].isin([redis_idcard])]
                    if gather_data_df.shape[0]>0:
			print 'gather_data'
                        gather_data_df['col_time'] = time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time()))
			#gather_rule.rename(columns={'prog_id':'plan_id'},inplace=True) 
                        self.updateFreq(gather_rule,gather_data_df)
	
	#获取每个人的最后一次位置
	def getLastPlace(self,idcard,rule):
		last_dict = self.redisUtil.getRedisValue('control_last_place',idcard)
		last_device_id = rule['last_device_id']
		if last_dict != 0:
		    last_device_id = last_dict['dev_id']
		return last_device_id
	
	#更新每个人的最后一次位置
	def setLastPlace(self,data):
		for index,row in data.iterrows():
		    idcard = row['idcard']
		    v_df = row
		    v_df = v_df.to_dict()
		    value = json.dumps(v_df)
		    #print data
		    self.redisUtil.setRedisData('control_last_place',idcard,value)

	#规范化开始和结束时间格式
	def getTime(self,json_value):
		start_h = json_value['start_time'].replace(' ','')
		end_h = json_value['end_time'].replace(' ','')
		if len(start_h.split(':')[0])== 1:
		    start_h = '0%s' % start_h
                if len(end_h.split(':')[0])== 1:
                    end_h = '0%s' % end_h
		return start_h,end_h
	    
	#离开区域
	def leaveArea(self,data,rule):
        	idcard = data['idcard']
		res = self.judgeExe(data,rule)
		rs = []
		if res == 0 or rule['idcard'] != idcard:
			return 0
		print 'idcard:%s' % idcard
		control_times = res[0]
		col_h = res[1]
		last_device_id = self.getLastPlace(idcard,rule)
		#print last_device_id
        	for json_key in control_times:
                    if json_key == 'value':
		        for json_value in control_times[json_key]:
			    j_time = self.getTime(json_value)  
                            start_h = j_time[0]
                            end_h = j_time[1]
			    #数据时间要在规则设定时间内,而且此人的上次位置在区域内，此次位置不在区域内
                            if (col_h >= start_h and col_h<=end_h):
				#区域内的全部设备id
				#print col_h
                                dev_list = str(rule['target_json']).replace('[','').replace(']','').split(',')
                                device_id = str(data['dev_id'])
				print 'device_id:%s,last:%s' % (device_id,last_device_id)
				#print rule
                                if (device_id not in dev_list ) and (last_device_id in dev_list):

                                    rs.append((self.ruleRes(rule),self.dataRes(rule,data)))
				    print 'leaveArea'
                        	else:
				    pass
		return rs

        #进入区域
        def intoArea(self,data,rule):
                idcard = data['idcard']
                res = self.judgeExe(data,rule)
		rs = []
                if res == 0 or rule['idcard'] != idcard:
                        return 0
                control_times = res[0]
                col_h = res[1]
		last_device_id = self.getLastPlace(idcard,rule)
                for json_key in control_times:
                    if json_key == 'value':
                        for json_value in control_times[json_key]:
                            j_time = self.getTime(json_value)
                            start_h = j_time[0]
                            end_h = j_time[1]
			    #数据时间要在规则设定时间内,而且此人的上次位置不在区域内，此次位置在区域内
                            if (col_h >= start_h and col_h<=end_h):
				#区域内的全部设备id
                                dev_list= str(rule['target_json']).replace('[','').replace(']','').split(',')
                                device_id = data['dev_id']
                                if (device_id in dev_list) and (last_device_id not in dev_list):
                                    rs.append((self.ruleRes(rule),self.dataRes(rule,data)))
				    print 'intoArea'
                                else:
                                    pass
		return rs	

	#随动随报
	def appearAlarm(self,data,rule):
		idcard = data['idcard']
                res = self.judgeExe(data,rule)
		rs = []
                if res == 0 or rule['idcard'] != idcard:
                        return 0
                control_times = res[0]
                col_h = res[1]
		behavior = data['data_source']
		target_name = rule['prog_target']
		if behavior != target_name:
                                    print 'positionAlarm_into'
		return rs

	#聚集预警	
	def gatherAlarm(self,data,rule):
		res = self.judgeExe(data,rule)
		rs = []
                if res == 0:
                        return 0
                control_times = res[0]
		print rule
                col_h = res[1]
		col_time = str(data['col_time'])
		idcard = data['idcard']
		device_id = data['device_id']
		keep_time = '0'
		first_time = col_time
		last_device_id = device_id

                for json_key in control_times:
                    if json_key == 'value':
                        for json_value in control_times[json_key]:
                            start_h = json_value['start_time']
                            end_h = json_value['end_time']
			    dev_list= str(rule['target_json']).split(',')
			    target_id = rule['target_id']
			    #redis存储了区域的id和进入区域的所有人的idcard,first_time(首次进入区域时间),上次经过的设备id,停留时长
			    last_rs = redisUtils.getRedisValue('target_id_%s' % target_id,idcard)
			    if last_rs != 0:
			        last_device_id = last_rs['dev_id']
			    #如果此人离开区域就把此人从进入区域人员列表中删除
			    print 'target_id_%s' % target_id
			    if (device_id not in dev_list ) and (last_device_id in dev_list):
				redisUtils.delRedisHashKey('target_id_%s' % target_id,idcard)
			    print '----------------------------------'
			    
                            #数据时间要在规则设定时间内,如果在目标的停留时间超过设定值则预警
                            if (col_h >= start_h and col_h<=end_h and (device_id in dev_list)):
				#0代表在redis中没有找到此人的信息
				if last_rs == 0:
				    keep_time = '0'
				else:
				    first_time = last_rs['first_time']
				    
				    #停留时长
				    seds =  (datetime.datetime.now()-datetime.datetime.strptime(first_time,'%Y-%m-%d %H:%M:%S')).seconds
                		    m,s =divmod(seds,60) 
				    keep_time = str(m)
				print '%s,%s' % (first_time,keep_time)
                                redisUtils.setRedisData('target_id_%s' % target_id,idcard,'%s,%s,%s' % (first_time,device_id,keep_time))
				#prog_rule_json = json.loads(str(rule['prog_rule']))
                                #stay_time = prog_rule_json['stay_time']
				#if keep_time >= stay_time:
				#    g_data = self.dataRes(rule,data)
				#    rule_r = self.ruleRes(rule)
				#    rule_r['idcard'] = rule['idcard']
				#    rs.append((rule_r,self.dataRes(rule,data)))
				    print 'gatherAlarm'
                            else:
                                pass
		return rs


	#把每条规则的参数返回成一个dict
	def ruleRes(self,rule_df):
		control_id = rule_df['control_id']
		plan_id = rule_df['prog_id']
                target_id = int(rule_df['target_id'])
                prog_rule = rule_df['prog_rule']
                prog_rule_json = json.loads(prog_rule)
                times = prog_rule_json['times']
		return {"control_id":control_id,"plan_id":plan_id,"target_id":target_id,"prog_target":rule_df['prog_target'],"set_num":times,"control_prog":rule_df['control_prog'],"leader_state":rule_df['leader_state'],"emergency_grade":rule_df['emergency_grade'],"create_user":rule_df['create_user'],"update_user":rule_df['update_user'],"is_delete":rule_df['is_delete']}
	
	#把每条数据加上布控的id信息，方便预警信息插入
	def dataRes(self,rule_df,data):
                control_id = rule_df['control_id']
                plan_id = rule_df['prog_id']
                target_id = int(rule_df['target_id'])
		data['control_id'] = control_id
		data['plan_id'] = plan_id
		data['target_id'] = target_id
		#dict类型
		if type(data) == dict:
		    return data
		return data.to_dict()

	#更新触警频次表
	def updateFreq(self,rule_df,data_df):
        	print 'updateFreq'
		#print rule_df
		mysql_conf = self.conf['mysql']
		touch_df_t = rule_df
		touch_df_t = touch_df_t.drop_duplicates()
		if touch_df_t.shape[0]>0:
	            MysqlUtils.saveTouchFreq(mysql_conf,touch_df_t)
		touch_df = MysqlUtils.get_data(mysql_conf,mysql_conf['touch_freq_tb'])
		touch_df = touch_df[touch_df['touch_num']%touch_df['set_num']==0]
		if touch_df.shape[0]>0 and rule_df.shape[0]>0:
		    
		    rules = touch_df.merge(rule_df,on=['control_id','plan_id','target_id'],how='inner')
		    if rules.shape[0]>0:
			print rules.head(1)
		        res_df = rules.merge(data_df,on=['control_id','plan_id','target_id'],how='inner')
		        res_df.drop_duplicates()
		        #print res_df.head(10)
		        self.saveAlarmInfo(res_df)
			

	#告警信息写入
	def saveAlarmInfo(self,data): 
		print 'saveAlarmInfo'
		cur_time = str(time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time())))
		res_l = []
		#数据整理为mysql表所需要的结构
		for index,row in data.iterrows():
		    print row
		    t = {"emergency_date":row['col_time'],"emergency_name":row['control_prog_x'],"device_id":row['device_id'],"object_business_code":row['idcard'],"person_id":row['idcard'],"leader_state":row['leader_state_x'],"emergency_source":'1',"emergency_reason":'%s 身份证号:%s触发%s告警;告警目标:%s 告警位置:%s'%(row['name'],row['idcard'],row['control_prog_x'],row['prog_target_x'],row['device_name']),"policeman_state":'2',"lon":row['jd'],"lat":row['wd'],"plan_target_id":row['target_id'],"plan_id":row['plan_id'],"control_id":row['control_id'],"emergency_location":row['device_name'],"emergency_grade":row['emergency_grade_x'],"city":row['device_city'],"city_code":row['city_code'],"district":row['device_district'],"district_code":row['district_code'],"create_user":row['create_user_x'],"create_time":cur_time,"update_user":row['update_user_x'],"update_time":cur_time,"is_delete":row['is_delete_x']}
		    res_l.append(t)
		print '----------------------------------------------'
		df = pd.DataFrame(res_l)
		#print df['emergency_reason'].head(10)
		#告警信息写入
		df = df.drop_duplicates()
		mysql_conf = self.conf['mysql']
		MysqlUtils.saveAlarmInfo(mysql_conf,df)
			
